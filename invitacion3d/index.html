<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Invitaci칩n Boda - Pase de Abordar 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Tipograf칤a base -->
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #2b3a4a, #050810);
      color: #f5f5f5;
      font-family: "Lato", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    .wrapper {
      width: 100%;
      max-width: 900px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    h1 {
      font-size: 1.1rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      text-align: center;
      margin: 8px 0;
      opacity: 0.9;
    }
    .sub {
      font-size: 0.85rem;
      text-align: center;
      opacity: 0.8;
      max-width: 520px;
    }
    #canvas-container {
      width: 100%;
      aspect-ratio: 16 / 9;
      max-height: 480px;
      margin-top: 8px;
      border-radius: 18px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      background: radial-gradient(circle at center, #132032, #050810);
    }
    canvas {
      display: block;
    }
    .info-card {
      margin-top: 8px;
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(5, 8, 16, 0.85);
      border: 1px solid rgba(255,255,255,0.05);
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: 100%;
      max-width: 600px;
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      flex-wrap: wrap;
      gap: 8px;
    }
    .label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.7rem;
      opacity: 0.7;
    }
    .value {
      font-weight: 600;
    }
    .secondary {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-top: 4px;
    }
    .hint {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 2px;
    }
    .error {
      margin-top: 16px;
      color: #ffb3b3;
      font-size: 0.9rem;
      text-align: center;
    }
    #baseTicketFront,
    #baseTicketBack {
      display: none;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Pase de abordar &mdash; Boda Cynthia &amp; Jos칠 Miguel</h1>
    <p class="sub">
      Arrastra con el dedo o el mouse para girar tu boleto.<br />
      Esta invitaci칩n es 칰nica y est치 hecha solo para ti 九걾잺
    </p>

    <div id="canvas-container"></div>

    <div class="info-card">
      <div class="info-row">
        <div>
          <div class="label">Pasajero</div>
          <div class="value" id="info-nombre">Invitado especial</div>
        </div>
        <div>
          <div class="label">Ruta</div>
          <div class="value">
            <span id="info-desde">Ciudad origen</span>
            &nbsp;&rarr;&nbsp;
            <span id="info-hacia">Playa del Carmen</span>
          </div>
        </div>
      </div>
      <div class="info-row">
        <div>
          <div class="label">Fecha</div>
          <div class="value">06 febrero 2026 &bull; 18:00 h</div>
        </div>
        <div>
          <div class="label">Destino</div>
          <div class="value">Playa del Carmen, M칠xico</div>
        </div>
      </div>
      <div class="secondary">
        Esta es la versi칩n digital de tu invitaci칩n.
      </div>
      <div class="hint">
        Tip: gira el celular en horizontal para verlo m치s grande.
      </div>
    </div>

    <div class="error" id="error-msg" style="display:none;"></div>
  </div>

  <!-- Im치genes base del boleto (frente y reverso) -->
  <img id="baseTicketFront" src="boleto-front.png" alt="Boleto frente" />
  <img id="baseTicketBack"  src="boleto-back.png"  alt="Boleto reverso" />

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <!-- Librer칤a para generar QR en el canvas (sin im치genes externas) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>

  <script>
    /***** CONFIG: URL de tu Apps Script (termina en /exec) *****/
    const API_URL = 'https://script.google.com/macros/s/AKfycbzBtlmIjacWcpdhzd8pnyhvL_mQtj8arptSGXeu5vYosB1PWb788D1lsXaO6FXNTU_B/exec'; // 游녣 CAMBIAR

    function getTokenFromURL() {
      const params = new URLSearchParams(window.location.search);
      return (params.get('t') || params.get('token') || '').trim();
    }

    async function fetchInvitado(token) {
      if (!token) return null;
      const url = API_URL + '?token=' + encodeURIComponent(token);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const json = await resp.json();
      if (!json.ok) throw new Error(json.error || 'Token no encontrado');
      return json.data; // { token, nombre, desde, hacia }
    }

    function waitForImage(img) {
      return new Promise((resolve) => {
        if (img.complete) return resolve();
        img.onload = () => resolve();
        img.onerror = () => resolve();
      });
    }

    window.addEventListener('load', async () => {
      const errorMsg = document.getElementById('error-msg');
      const infoNombre = document.getElementById('info-nombre');
      const infoDesde = document.getElementById('info-desde');
      const infoHacia = document.getElementById('info-hacia');

      const token = getTokenFromURL();
      let invitado = null;

      try {
        invitado = await fetchInvitado(token);
      } catch (err) {
        console.error(err);
        errorMsg.style.display = 'block';
        errorMsg.textContent =
          'No se pudo cargar tu invitaci칩n. Verifica el enlace o contacta a los novios. (' +
          err.message +
          ')';
      }

      if (invitado) {
        infoNombre.textContent = invitado.nombre || 'Invitado especial';
        infoDesde.textContent = invitado.desde || 'Origen';
        infoHacia.textContent = invitado.hacia || 'Destino';
      }

      const imgFront = document.getElementById('baseTicketFront');
      const imgBack  = document.getElementById('baseTicketBack');

      await Promise.all([waitForImage(imgFront), waitForImage(imgBack)]);
      startThree(invitado, imgFront, imgBack);
    });

    // ------- QR helper (usa qrcode-generator para dibujarlo directamente en el canvas) -------
    function drawQRCodeOnCanvas(ctx, x, y, size, text) {
      const typeNumber = 0; // auto
      const errorCorrection = 'M';
      const qr = qrcode(typeNumber, errorCorrection);
      qr.addData(text);
      qr.make();

      const count = qr.getModuleCount();
      const cellSize = size / count;

      ctx.save();
      ctx.translate(x, y);

      // fondo blanco
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, size, size);

      // m칩dulos negros
      ctx.fillStyle = '#000000';
      for (let row = 0; row < count; row++) {
        for (let col = 0; col < count; col++) {
          if (qr.isDark(row, col)) {
            const w = Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize);
            const h = Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize);
            ctx.fillRect(
              Math.round(col * cellSize),
              Math.round(row * cellSize),
              w,
              h
            );
          }
        }
      }

      ctx.restore();
    }

    // -----------------------------------------------------------------------------------

    function startThree(invitado, imgFront, imgBack) {
      const container = document.getElementById('canvas-container');

      // ==== CANVAS FRENTE ====
      const canvasFront = document.createElement('canvas');
      const ctxFront = canvasFront.getContext('2d');
      canvasFront.width  = imgFront.naturalWidth;
      canvasFront.height = imgFront.naturalHeight;

      // ==== CANVAS REVERSO ====
      const canvasBack = document.createElement('canvas');
      const ctxBack = canvasBack.getContext('2d');
      canvasBack.width  = imgBack.naturalWidth;
      canvasBack.height = imgBack.naturalHeight;

      const frontTexture = new THREE.CanvasTexture(canvasFront);
      const backTexture  = new THREE.CanvasTexture(canvasBack);

      // ================== FRENTE ==================
      function dibujarFrente(data) {
        ctxFront.clearRect(0, 0, canvasFront.width, canvasFront.height);
        ctxFront.drawImage(imgFront, 0, 0, canvasFront.width, canvasFront.height);

        if (!data) {
          frontTexture.needsUpdate = true;
          return;
        }

        ctxFront.fillStyle = '#222222';
        ctxFront.textAlign = 'left';
        ctxFront.textBaseline = 'middle';

        const scaleX = canvasFront.width / 2000;
        const scaleY = canvasFront.height / 700;

        // Nombre del pasajero (junto a "NOMBRE DEL PASAJERO:")
        const xNombreBase = 570;
        const yNombreBase = 585;
        const xNombre = xNombreBase * scaleX;
        const yNombre = yNombreBase * scaleY;

        const nombre = (data.nombre || '').toUpperCase();
        const maxNombreWidth = (1900 - xNombreBase) * scaleX;

        let fontSizeNombre = 30 * scaleY;
        while (true) {
          ctxFront.font = `${fontSizeNombre}px "Lato", system-ui, sans-serif`;
          const widthText = ctxFront.measureText(nombre).width;
          if (widthText <= maxNombreWidth || fontSizeNombre <= 16 * scaleY) break;
          fontSizeNombre -= 1 * scaleY;
        }
        ctxFront.fillText(nombre, xNombre, yNombre);

        // DE / A panel derecho
        const desde = (data.desde || '').toUpperCase();
        const hacia = (data.hacia || '').toUpperCase();

        ctxFront.font = `${22 * scaleY}px "Lato", system-ui, sans-serif`;
        ctxFront.fillText(desde, 1605 * scaleX, 290 * scaleY);
        ctxFront.fillText(hacia, 1845 * scaleX, 290 * scaleY);

        frontTexture.needsUpdate = true;
      }

      // ================== REVERSO ==================
      function dibujarReverso(data) {
        ctxBack.clearRect(0, 0, canvasBack.width, canvasBack.height);
        ctxBack.drawImage(imgBack, 0, 0, canvasBack.width, canvasBack.height);

        if (!data || !data.token) {
          backTexture.needsUpdate = true;
          return;
        }

        const w = canvasBack.width;
        const h = canvasBack.height;

        const urlDestino =
          'https://cynthiayjosemiguel.com.mx/invitacion/?t=' +
          encodeURIComponent(data.token);

const qrSize = h * 0.4;          // tama침o igual
const marginLeft = w * 0.05;     // margen desde el borde izquierdo
const x = marginLeft;            // ahora a la izquierda
const y = (h - qrSize) / 2;      // centrado vertical

drawQRCodeOnCanvas(ctxBack, x, y, qrSize, urlDestino);

        backTexture.needsUpdate = true;
      }

      dibujarFrente(invitado);
      dibujarReverso(invitado);

      // ================== THREE.JS ==================
      const scene = new THREE.Scene();
      scene.background = null;

      const fov = 35;
      const aspect = container.clientWidth / container.clientHeight;
      const camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 100);
      camera.position.set(0, 0.1, 3.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(2, 4, 3);
      scene.add(dirLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
      backLight.position.set(-2, -3, -2);
      scene.add(backLight);

      const imgAspect = canvasFront.width / canvasFront.height;
      const planeHeight = 1.4;
      const planeWidth  = planeHeight * imgAspect;

      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

      const frontMaterial = new THREE.MeshStandardMaterial({
        map: frontTexture,
        roughness: 0.35,
        metalness: 0.05
      });
      const backMaterial = new THREE.MeshStandardMaterial({
        map: backTexture,
        roughness: 0.35,
        metalness: 0.05
      });

      const ticketGroup = new THREE.Group();

      const planeFront = new THREE.Mesh(geometry, frontMaterial);
      planeFront.rotation.x = -0.15;
      planeFront.rotation.y = 0.4;

      const planeBack = new THREE.Mesh(geometry, backMaterial);
      planeBack.rotation.x = -0.15;
      planeBack.rotation.y = 0.4 + Math.PI;

      ticketGroup.add(planeFront);
      ticketGroup.add(planeBack);
      scene.add(ticketGroup);

      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };
      let autoRotate = true;

      function getPointerPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      function onPointerDown(e) {
        isDragging = true;
        autoRotate = false;
        previousMousePosition = getPointerPos(e);
      }

      function onPointerMove(e) {
        if (!isDragging) return;
        const pos = getPointerPos(e);
        const deltaMove = {
          x: pos.x - previousMousePosition.x,
          y: pos.y - previousMousePosition.y
        };

        ticketGroup.rotation.y += deltaMove.x * 0.005;
        ticketGroup.rotation.x += deltaMove.y * 0.005;

        previousMousePosition = pos;
      }

      function onPointerUp() {
        isDragging = false;
        setTimeout(() => { autoRotate = true; }, 1200);
      }

      renderer.domElement.addEventListener('mousedown', onPointerDown);
      renderer.domElement.addEventListener('mousemove', onPointerMove);
      window.addEventListener('mouseup', onPointerUp);

      renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: true });
      renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: true });
      window.addEventListener('touchend', onPointerUp);

      window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });

      function animate() {
        requestAnimationFrame(animate);
        if (autoRotate) {
          ticketGroup.rotation.y += 0.003;
        }
        renderer.render(scene, camera);
      }
      animate();
    }
  </script>
</body>
</html>
